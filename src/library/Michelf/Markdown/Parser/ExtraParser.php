<?php
/**
 * This file was generated by a build-script. Do not edit.
 *
 * @package Michelf_Markdown_Parser
 * @author Michel Fortin, <http://michelf.com/>
 * @copyright 2004-2013 Michel Fortin, <http://michelf.com/>
 * @link http://michelf.com/projects/php-markdown/
 */
namespace Michelf\Markdown\Parser;

use Michelf\Markdown\Parser\CoreParser;

/**
 * This class was extracted from the `markdown.php` file by a build-script,
 * DO NOT EDIT HERE!
 *
 * What was modified?
 *
 * + Classes were extracted into separate files.
 * + Classes were renamed.
 * + A namespace was added.
 * + The class constructor was renamed.
 * + Some unused constants were removed.
 * + Code was formatted using PHP-CS-Fixer
 * + Documentation was generated using phpdocumentor2
 *
 * @package Michelf_Markdown_Parser
 * @author Michel Fortin, <http://michelf.com/>
 * @copyright 2004-2013 Michel Fortin, <http://michelf.com/>
 * @link http://michelf.com/projects/php-markdown/
 * @todo Add DocBlock for class properties.
 * @todo Add DocBlock for class methods.
 * @fixme Get rid of constants, use class options/config and defaults.
 * @fixme Stop passing $this as reference
 * @link http://php.net/manual/en/language.references.pass.php} otherwise
 *		PHP 5.4 wil raise a fatal error.
 */
class ExtraParser extends CoreParser
{
    const EMPTY_ELEMENT_SUFFIX = " />";
    const TAB_WIDTH = 4;
    const FN_LINK_TITLE = "";
    const FN_BACKLINK_TITLE = "";
    const FN_LINK_CLASS = "";
    const FN_BACKLINK_CLASS = "";
    const CODE_CLASS_PREFIX = "";
    const CODE_ATTR_ON_PRE = false;

    ### Configuration Variables ###

    # Prefix for footnote ids.
    public $fn_id_prefix = "";

    # Optional title attribute for footnote links and backlinks.
    public $fn_link_title = self::FN_LINK_TITLE;
    public $fn_backlink_title = self::FN_BACKLINK_TITLE;

    # Optional class attribute for footnote links and backlinks.
    public $fn_link_class = self::FN_LINK_CLASS;
    public $fn_backlink_class = self::FN_BACKLINK_CLASS;

    # Optional class prefix for fenced code block.
    public $code_class_prefix = self::CODE_CLASS_PREFIX;
    # Class attribute for code blocks goes on the `code` tag;
    # setting this to true will put attributes on the `pre` tag instead.
    public $code_attr_on_pre = self::CODE_ATTR_ON_PRE;

    # Predefined abbreviations.
    public $predef_abbr = array();

    ### Parser Implementation ###

    public function __construct()
    {
    #
    # Constructor function. Initialize the parser object.
    #
        # Add extra escapable characters before parent constructor
        # initialize the table.
        $this->escape_chars .= ':|';

        # Insert extra document, block, and span transformations.
        # Parent constructor will do the sorting.
        $this->document_gamut += array(
            "doFencedCodeBlocks" => 5,
            "stripFootnotes"     => 15,
            "stripAbbreviations" => 25,
            "appendFootnotes"    => 50,
            );
        $this->block_gamut += array(
            "doFencedCodeBlocks" => 5,
            "doTables"           => 15,
            "doDefLists"         => 45,
            );
        $this->span_gamut += array(
            "doFootnotes"        => 5,
            "doAbbreviations"    => 70,
            );

        parent::__construct();
    }

    # Extra variables used during extra transformations.
    public $footnotes = array();
    public $footnotes_ordered = array();
    public $footnotes_ref_count = array();
    public $footnotes_numbers = array();
    public $abbr_desciptions = array();
    public $abbr_word_re = '';

    # Give the current footnote number.
    public $footnote_counter = 1;

    public function setup()
    {
    #
    # Setting up Extra-specific variables.
    #
        parent::setup();

        $this->footnotes = array();
        $this->footnotes_ordered = array();
        $this->footnotes_ref_count = array();
        $this->footnotes_numbers = array();
        $this->abbr_desciptions = array();
        $this->abbr_word_re = '';
        $this->footnote_counter = 1;

        foreach ($this->predef_abbr as $abbr_word => $abbr_desc) {
            if ($this->abbr_word_re)
                $this->abbr_word_re .= '|';
            $this->abbr_word_re .= preg_quote($abbr_word);
            $this->abbr_desciptions[$abbr_word] = trim($abbr_desc);
        }
    }

    public function teardown()
    {
    #
    # Clearing Extra-specific variables.
    #
        $this->footnotes = array();
        $this->footnotes_ordered = array();
        $this->footnotes_ref_count = array();
        $this->footnotes_numbers = array();
        $this->abbr_desciptions = array();
        $this->abbr_word_re = '';

        parent::teardown();
    }

    ### Extra Attribute Parser ###

    # Expression to use to catch attributes (includes the braces)
    public $id_class_attr_catch_re = '\{((?:[ ]*[#.][-_:a-zA-Z0-9]+){1,})[ ]*\}';
    # Expression to use when parsing in a context when no capture is desired
    public $id_class_attr_nocatch_re = '\{(?:[ ]*[#.][-_:a-zA-Z0-9]+){1,}[ ]*\}';

    public function doExtraAttributes($tag_name, $attr)
    {
    #
    # Parse attributes caught by the $this->id_class_attr_catch_re expression
    # and return the HTML-formatted list of attributes.
    #
    # Currently supported attributes are .class and #id.
    #
        if (empty($attr)) return "";

        # Split on components
        preg_match_all("/[.#][-_:a-zA-Z0-9]+/", $attr, $matches);
        $elements = $matches[0];

        # handle classes and ids (only first id taken into account)
        $classes = array();
        $id = false;
        foreach ($elements as $element) {
            if ($element{0} == '.') {
                $classes[] = substr($element, 1);
            } elseif ($element{0} == '#') {
                if ($id === false) $id = substr($element, 1);
            }
        }

        # compose attributes as string
        $attr_str = "";
        if (!empty($id)) {
            $attr_str .= ' id="'.$id.'"';
        }
        if (!empty($classes)) {
            $attr_str .= ' class="'.implode(" ", $classes).'"';
        }

        return $attr_str;
    }

    ### HTML Block Parser ###

    # Tags that are always treated as block tags:
    public $block_tags_re = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|form|fieldset|iframe|hr|legend|article|section|nav|aside|hgroup|header|footer|figcaption';

    # Tags treated as block tags only if the opening tag is alone on its line:
    public $context_block_tags_re = 'script|noscript|ins|del|iframe|object|source|track|param|math|svg|canvas|audio|video';

    # Tags where markdown="1" default to span mode:
    public $contain_span_tags_re = 'p|h[1-6]|li|dd|dt|td|th|legend|address';

    # Tags which must not have their contents modified, no matter where
    # they appear:
    public $clean_tags_re = 'script|math|svg';

    # Tags that do not need to be closed.
    public $auto_close_tags_re = 'hr|img|param|source|track';

    public function hashHTMLBlocks($text)
    {
    #
    # Hashify HTML Blocks and "clean tags".
    #
    # We only want to do this for block-level HTML tags, such as headers,
    # lists, and tables. That's because we still want to wrap <p>s around
    # "paragraphs" that are wrapped in non-block-level tags, such as anchors,
    # phrase emphasis, and spans. The list of tags we're looking for is
    # hard-coded.
    #
    # This works by calling _HashHTMLBlocks_InMarkdown, which then calls
    # _HashHTMLBlocks_InHTML when it encounter block tags. When the markdown="1"
    # attribute is found within a tag, _HashHTMLBlocks_InHTML calls back
    #  _HashHTMLBlocks_InMarkdown to handle the Markdown syntax within the tag.
    # These two functions are calling each other. It's recursive!
    #
        if ($this->no_markup)  return $text;

        #
        # Call the HTML-in-Markdown hasher.
        #
        list($text, ) = $this->_hashHTMLBlocks_inMarkdown($text);

        return $text;
    }
    public function _hashHTMLBlocks_inMarkdown($text, $indent = 0,
                                        $enclosing_tag_re = '', $span = false)
    {
    #
    # Parse markdown text, calling _HashHTMLBlocks_InHTML for block tags.
    #
    # *   $indent is the number of space to be ignored when checking for code
    #     blocks. This is important because if we don't take the indent into
    #     account, something like this (which looks right) won't work as expected:
    #
    #     <div>
    #         <div markdown="1">
    #         Hello World.  <-- Is this a Markdown code block or text?
    #         </div>  <-- Is this a Markdown code block or a real tag?
    #     <div>
    #
    #     If you don't like this, just don't indent the tag on which
    #     you apply the markdown="1" attribute.
    #
    # *   If $enclosing_tag_re is not empty, stops at the first unmatched closing
    #     tag with that name. Nested tags supported.
    #
    # *   If $span is true, text inside must treated as span. So any double
    #     newline will be replaced by a single newline so that it does not create
    #     paragraphs.
    #
    # Returns an array of that form: ( processed text , remaining text )
    #
        if ($text === '') return array('', '');

        # Regex to check for the presense of newlines around a block tag.
        $newline_before_re = '/(?:^\n?|\n\n)*$/';
        $newline_after_re =
            '{
                ^						# Start of text following the tag.
                (?>[ ]*<!--.*?-->)?		# Optional comment.
                [ ]*\n					# Must be followed by newline.
            }xs';

        # Regex to match any tag.
        $block_tag_re =
            '{
                (					# $2: Capture whole tag.
                    </?					# Any opening or closing tag.
                        (?>				# Tag name.
                            '.$this->block_tags_re.'			|
                            '.$this->context_block_tags_re.'	|
                            '.$this->clean_tags_re.'        	|
                            (?!\s)'.$enclosing_tag_re.'
                        )
                        (?:
                            (?=[\s"\'/a-zA-Z0-9])	# Allowed characters after tag name.
                            (?>
                                ".*?"		|	# Double quotes (can contain `>`)
                                \'.*?\'   	|	# Single quotes (can contain `>`)
                                .+?				# Anything but quotes and `>`.
                            )*?
                        )?
                    >					# End of tag.
                |
                    <!--    .*?     -->	# HTML Comment
                |
                    <\?.*?\?> | <%.*?%>	# Processing instruction
                |
                    <!\[CDATA\[.*?\]\]>	# CData Block
                |
                    # Code span marker
                    `+
                '. ( !$span ? ' # If not in span.
                |
                    # Indented code block
                    (?: ^[ ]*\n | ^ | \n[ ]*\n )
                    [ ]{'.($indent+4).'}[^\n]* \n
                    (?>
                        (?: [ ]{'.($indent+4).'}[^\n]* | [ ]* ) \n
                    )*
                |
                    # Fenced code block marker
                    (?> ^ | \n )
                    [ ]{0,'.($indent+3).'}超莳亢郛菘郗吆岘镰诎馆篝犷溽祜铄沆狍钺礤М翳轶鹃溥沆狍筮狒趄哳镢狒汨唑瀹屮趄狒趄殁豸弩┛莳茴Ё┊蓬ㄩ铒轶箴犷┊螫や屦翳盎悯蝌孱溴痿轭箝溴翳翎趄邋ゐ狎箦⒒嗅蝮邃翦翳狒鏖祆忮蝈趱蝾邃田镳翳蝻蹒弼弪翎躅糸麇骈钿翳沆矬轭翎镦翳疳蝈铘矧祜镳躅糸蝈徙栝铉翳孱镦翦殒铒疳蝈铘翎箴邈殒殄洚滹羽扉翳翦躞轭翳骈蝮翎邕磲翥疳趑弪骘躅洚藻忮骘蝈疳趑弪鏖祆忮骈蝮轭翳狎蜥翦徭翦疳趑弪鏖祆忮狒翳孱洮犷忮赭邋鏖祆忮犷汜翥桢磲溴怡翳疳趑弪町ゐ狎趔痱彗唧痨轸à忪镢脒翎邕蝈翦衄铂幸徘哂刑稍吣盘赏呙列哉遗┗涉轭歪螂滹黝箴犷盹溴徜屙痿篝蜷铉箴犷戾鲥栳箬徭翦遽汨铄黛轭麸痱弼孱趄殓珏蜷铉犷忪镢屐屙孱舢殒à箴犷鲲殇翳轶捐狍栊狎舁ШЗゎ鬻扉铄鲲殇茴⒒ゐ狎趔郯鲲殇篝蜻蝈痨徙濞④睥ゎ鬻扉铄ゐ狎趔郯荸鲲殇ゐ狎箦ゐ狎趔郯莼藻忮骘蝈沲蝌孱翎绠涉孱镦翦栳忮孱蝈徙桢洚郁镳祜镳殒ㄣ秕铘à疳螋螬畅翦⒒怛遽牖翎ゐ狎趔郾莼葬麸栳钿戾翦ゐ狎趔鄄莼义磲轭轭翦徭翦沲蝌孱翎绠翎邕蝈痱彗唏躏翦à翎绌骑躞轭蝈珲灬屮痱弩箝镱描邈骘蚝蔑溴箴犷磲螂弪殒à翎琨褒浇⑧崎钿泔蝌弩痫钿轭孱磲螂弪翎邕蝈痱彗唏躏翦à翎绌殒痱彗唔狒汨ě蕤烤奎茴俊茴┅卡考∴┃翎邕蝈Ж俊喋К翦衄ろ狒汨弩┅蓬磲螂弪骘躅浜疳篌翦躅汨犷珏躅糸磲螂弪ゐ狎箦翎ろ狒汨弩郯莼翦篚怏趄à翦衄篝蜢孱à磲翥桢筵拜┅屐箦疹磲翥桢磲螂弪牾篝箅轲轸ゐ狎箦翎缁描邈骘蚝棋钽邃泔溴忪镢磲螂弪屐箦殒痱彗唔狒汨ě捃羁蓰艾Мà轭溴铘畅', $tag)) {
                # Fenced code block marker: find matching end marker.
                $tag_re = preg_quote(trim($tag));
                if (preg_match('{^(?>.*\n)+?[ ]{0,'.($indent).'}'.$tag_re.'[ ]*\n}', $text,
                    $matches))
                {
                    # End marker found: pass text unchanged until marker.
                    $parsed .= $tag . $matches[0];
                    $text = substr($text, strlen($matches[0]));
                } else {
                    # No end marker: just skip it.
                    $parsed .= $tag;
                }
            }
            #
            # Check for: Indented code block.
            #
            else if ($tag{0} == "\n" || $tag{0} == " ") {
                # Indented code block: pass it unchanged, will be handled
                # later.
                $parsed .= $tag;
            }
            #
            # Check for: Opening Block level tag or
            #            Opening Context Block tag (like ins and del)
            #               used as a block tag (tag is alone on it's line).
            #
            else if (preg_match('{^<(?:'.$this->block_tags_re.')\b}', $tag) ||
                (	preg_match('{^<(?:'.$this->context_block_tags_re.')\b}', $tag) &&
                    preg_match($newline_before_re, $parsed) &&
                    preg_match($newline_after_re, $text)	)
                )
            {
                # Need to parse tag and following text using the HTML parser.
                list($block_text, $text) =
                    $this->_hashHTMLBlocks_inHTML($tag . $text, "hashBlock", true);

                # Make sure it stays outside of any paragraph by adding newlines.
                $parsed .= "\n\n$block_text\n\n";
            }
            #
            # Check for: Clean tag (like script, math)
            #            HTML Comments, processing instructions.
            #
            else if (preg_match('{^<(?:'.$this->clean_tags_re.')\b}', $tag) ||
                $tag{1} == '!' || $tag{1} == '?')
            {
                # Need to parse tag and following text using the HTML parser.
                # (don't check for markdown attribute)
                list($block_text, $text) =
                    $this->_hashHTMLBlocks_inHTML($tag . $text, "hashClean", false);

                $parsed .= $block_text;
            }
            #
            # Check for: Tag with same name as enclosing tag.
            #
            else if ($enclosing_tag_re !== '' &&
                # Same name as enclosing tag.
                preg_match('{^</?(?:'.$enclosing_tag_re.')\b}', $tag))
            {
                #
                # Increase/decrease nested tag count.
                #
                if ($tag{1} == '/')						$depth--;
                else if ($tag{strlen($tag)-2} != '/')	$depth++;

                if ($depth < 0) {
                    #
                    # Going out of parent element. Clean up and break so we
                    # return to the calling function.
                    #
                    $text = $tag . $text;
                    break;
                }

                $parsed .= $tag;
            } else {
                $parsed .= $tag;
            }
        } while ($depth >= 0);

        return array($parsed, $text);
    }
    public function _hashHTMLBlocks_inHTML($text, $hash_method, $md_attr)
    {
    #
    # Parse HTML, calling _HashHTMLBlocks_InMarkdown for block tags.
    #
    # *   Calls $hash_method to convert any blocks.
    # *   Stops when the first opening tag closes.
    # *   $md_attr indicate if the use of the `markdown="1"` attribute is allowed.
    #     (it is not inside clean tags)
    #
    # Returns an array of that form: ( processed text , remaining text )
    #
        if ($text === '') return array('', '');

        # Regex to match `markdown` attribute inside of a tag.
        $markdown_attr_re = '
            {
                \s*			# Eat whitespace before the `markdown` attribute
                markdown
                \s*=\s*
                (?>
                    (["\'])		# $1: quote delimiter
                    (.*?)		# $2: attribute value
                    \1			# matching delimiter
                |
                    ([^\s>]*)	# $3: unquoted attribute value
                )
                ()				# $4: make $3 always defined (avoid warnings)
            }xs';

        # Regex to match any tag.
        $tag_re = '{
                (					# $2: Capture whole tag.
                    </?					# Any opening or closing tag.
                        [\w:$]+			# Tag name.
                        (?:
                            (?=[\s"\'/a-zA-Z0-9])	# Allowed characters after tag name.
                            (?>
                                ".*?"		|	# Double quotes (can contain `>`)
                                \'.*?\'   	|	# Single quotes (can contain `>`)
                                .+?				# Anything but quotes and `>`.
                            )*?
                        )?
                    >					# End of tag.
                |
                    <!--    .*?     -->	# HTML Comment
                |
                    <\?.*?\?> | <%.*?%>	# Processing instruction
                |
                    <!\[CDATA\[.*?\]\]>	# CData Block
                )
            }xs';

        $original_text = $text;		# Save original text in case of faliure.

        $depth		= 0;	# Current depth inside the tag tree.
        $block_text	= "";	# Temporary text holder for current text.
        $parsed		= "";	# Parsed text that will be returned.

        #
        # Get the name of the starting tag.
        # (This pattern makes $base_tag_name_re safe without quoting.)
        #
        if (preg_match('/^<([\w:$]*)\b/', $text, $matches))
            $base_tag_name_re = $matches[1];

        #
        # Loop through every tag until we find the corresponding closing tag.
        #
        do {
            #
            # Split the text using the first $tag_match pattern found.
            # Text before  pattern will be first in the array, text after
            # pattern will be at the end, and between will be any catches made
            # by the pattern.
            #
            $parts = preg_split($tag_re, $text, 2, PREG_SPLIT_DELIM_CAPTURE);

            if (count($parts) < 3) {
                #
                # End of $text reached with unbalenced tag(s).
                # In that case, we return original text unchanged and pass the
                # first character as filtered to prevent an infinite loop in the
                # parent function.
                #

                return array($original_text{0}, substr($original_text, 1));
            }

            $block_text .= $parts[0]; # Text before current tag.
            $tag         = $parts[1]; # Tag to handle.
            $text        = $parts[2]; # Remaining text after current tag.

            #
            # Check for: Auto-close tag (like <hr/>)
            #			 Comments and Processing Instructions.
            #
            if (preg_match('{^</?(?:'.$this->auto_close_tags_re.')\b}', $tag) ||
                $tag{1} == '!' || $tag{1} == '?')
            {
                # Just add the tag to the block as if it was text.
                $block_text .= $tag;
            } else {
                #
                # Increase/decrease nested tag count. Only do so if
                # the tag's name match base tag's.
                #
                if (preg_match('{^</?'.$base_tag_name_re.'\b}', $tag)) {
                    if ($tag{1} == '/')						$depth--;
                    else if ($tag{strlen($tag)-2} != '/')	$depth++;
                }

                #
                # Check for `markdown="1"` attribute and handle it.
                #
                if ($md_attr &&
                    preg_match($markdown_attr_re, $tag, $attr_m) &&
                    preg_match('/^1|block|span$/', $attr_m[2] . $attr_m[3]))
                {
                    # Remove `markdown` attribute from opening tag.
                    $tag = preg_replace($markdown_attr_re, '', $tag);

                    # Check if text inside this tag must be parsed in span mode.
                    $this->mode = $attr_m[2] . $attr_m[3];
                    $span_mode = $this->mode == 'span' || $this->mode != 'block' &&
                        preg_match('{^<(?:'.$this->contain_span_tags_re.')\b}', $tag);

                    # Calculate indent before tag.
                    if (preg_match('/(?:^|\n)( *?)(?! ).*?$/', $block_text, $matches)) {
                        $strlen = $this->utf8_strlen;
                        $indent = $strlen($matches[1], 'UTF-8');
                    } else {
                        $indent = 0;
                    }

                    # End preceding block with this tag.
                    $block_text .= $tag;
                    $parsed .= $this->$hash_method($block_text);

                    # Get enclosing tag name for the ParseMarkdown function.
                    # (This pattern makes $tag_name_re safe without quoting.)
                    preg_match('/^<([\w:$]*)\b/', $tag, $matches);
                    $tag_name_re = $matches[1];

                    # Parse the content using the HTML-in-Markdown parser.
                    list ($block_text, $text)
                        = $this->_hashHTMLBlocks_inMarkdown($text, $indent,
                            $tag_name_re, $span_mode);

                    # Outdent markdown text.
                    if ($indent > 0) {
                        $block_text = preg_replace("/^[ ]{1,$indent}/m", "",
                                                    $block_text);
                    }

                    # Append tag content to parsed text.
                    if (!$span_mode)	$parsed .= "\n\n$block_text\n\n";
                    else				$parsed .= "$block_text";

                    # Start over with a new block.
                    $block_text = "";
                } else $block_text .= $tag;
            }

        } while ($depth > 0);

        #
        # Hash last block text that wasn't processed inside the loop.
        #
        $parsed .= $this->$hash_method($block_text);

        return array($parsed, $text);
    }


    public function hashClean($text)
    {
    #
    # Called whenever a tag must be hashed when a function inserts a "clean" tag
    # in $text, it passes through this function and is automaticaly escaped,
    # blocking invalid nested overlap.
    #

        return $this->hashPart($text, 'C');
    }


    public function doHeaders($text)
    {
    #
    # Redefined to add id and class attribute support.
    #
        # Setext-style headers:
        #	  Header 1  {#header1}
        #	  ========
        #
        #	  Header 2  {#header2 .class1 .class2}
        #	  --------
        #
        $text = preg_replace_callback(
            '{
                (^.+?)								# $1: Header text
                (?:[ ]+ '.$this->id_class_attr_catch_re.' )?	 # $3 = id/class attributes
                [ ]*\n(=+|-+)[ ]*\n+				# $3: Header footer
            }mx',
            array(&$this, '_doHeaders_callback_setext'), $text);

        # atx-style headers:
        #	# Header 1        {#header1}
        #	## Header 2       {#header2}
        #	## Header 2 with closing hashes ##  {#header3.class1.class2}
        #	...
        #	###### Header 6   {.class2}
        #
        $text = preg_replace_callback('{
                ^(\#{1,6})	# $1 = string of #\'s
                [ ]*
                (.+?)		# $2 = Header text
                [ ]*
                \#*			# optional closing #\'s (not counted)
                (?:[ ]+ '.$this->id_class_attr_catch_re.' )?	 # $3 = id/class attributes
                [ ]*
                \n+
            }xm',
            array(&$this, '_doHeaders_callback_atx'), $text);

        return $text;
    }
    public function _doHeaders_callback_setext($matches)
    {
        if ($matches[3] == '-' && preg_match('{^- }', $matches[1]))

            return $matches[0];
        $level = $matches[3]{0} == '=' ? 1 : 2;
        $attr  = $this->doExtraAttributes("h$level", $dummy =& $matches[2]);
        $block = "<h$level$attr>".$this->runSpanGamut($matches[1])."</h$level>";

        return "\n" . $this->hashBlock($block) . "\n\n";
    }
    public function _doHeaders_callback_atx($matches)
    {
        $level = strlen($matches[1]);
        $attr  = $this->doExtraAttributes("h$level", $dummy =& $matches[3]);
        $block = "<h$level$attr>".$this->runSpanGamut($matches[2])."</h$level>";

        return "\n" . $this->hashBlock($block) . "\n\n";
    }

    public function doTables($text)
    {
    #
    # Form HTML tables.
    #
        $less_than_tab = $this->tab_width - 1;
        #
        # Find tables with leading pipe.
        #
        #	| Header 1 | Header 2
        #	| -------- | --------
        #	| Cell 1   | Cell 2
        #	| Cell 3   | Cell 4
        #
        $text = preg_replace_callback('
            {
                ^							# Start of a line
                [ ]{0,'.$less_than_tab.'}	# Allowed whitespace.
                [|]							# Optional leading pipe (present)
                (.+) \n						# $1: Header row (at least one pipe)

                [ ]{0,'.$less_than_tab.'}	# Allowed whitespace.
                [|] ([ ]*[-:]+[-| :]*) \n	# $2: Header underline

                (							# $3: Cells
                    (?>
                        [ ]*				# Allowed whitespace.
                        [|] .* \n			# Row content.
                    )*
                )
                (?=\n|\Z)					# Stop at final double newline.
            }xm',
            array(&$this, '_doTable_leadingPipe_callback'), $text);

        #
        # Find tables without leading pipe.
        #
        #	Header 1 | Header 2
        #	-------- | --------
        #	Cell 1   | Cell 2
        #	Cell 3   | Cell 4
        #
        $text = preg_replace_callback('
            {
                ^							# Start of a line
                [ ]{0,'.$less_than_tab.'}	# Allowed whitespace.
                (\S.*[|].*) \n				# $1: Header row (at least one pipe)

                [ ]{0,'.$less_than_tab.'}	# Allowed whitespace.
                ([-:]+[ ]*[|][-| :]*) \n	# $2: Header underline

                (							# $3: Cells
                    (?>
                        .* [|] .* \n		# Row content
                    )*
                )
                (?=\n|\Z)					# Stop at final double newline.
            }xm',
            array(&$this, '_DoTable_callback'), $text);

        return $text;
    }
    public function _doTable_leadingPipe_callback($matches)
    {
        $head		= $matches[1];
        $underline	= $matches[2];
        $content	= $matches[3];

        # Remove leading pipe for each row.
        $content	= preg_replace('/^ *[|]/m', '', $content);

        return $this->_doTable_callback(array($matches[0], $head, $underline, $content));
    }
    public function _doTable_callback($matches)
    {
        $head		= $matches[1];
        $underline	= $matches[2];
        $content	= $matches[3];

        # Remove any tailing pipes for each line.
        $head		= preg_replace('/[|] *$/m', '', $head);
        $underline	= preg_replace('/[|] *$/m', '', $underline);
        $content	= preg_replace('/[|] *$/m', '', $content);

        # Reading alignement from header underline.
        $separators	= preg_split('/ *[|] */', $underline);
        foreach ($separators as $n => $s) {
            if (preg_match('/^ *-+: *$/', $s))		$attr[$n] = ' align="right"';
            else if (preg_match('/^ *:-+: *$/', $s))$attr[$n] = ' align="center"';
            else if (preg_match('/^ *:-+ *$/', $s))	$attr[$n] = ' align="left"';
            else									$attr[$n] = '';
        }

        # Parsing span elements, including code spans, character escapes,
        # and inline HTML tags, so that pipes inside those gets ignored.
        $head		= $this->parseSpan($head);
        $headers	= preg_split('/ *[|] */', $head);
        $col_count	= count($headers);

        # Write column headers.
        $text = "<table>\n";
        $text .= "<thead>\n";
        $text .= "<tr>\n";
        foreach ($headers as $n => $header)
            $text .= "  <th$attr[$n]>".$this->runSpanGamut(trim($header))."</th>\n";
        $text .= "</tr>\n";
        $text .= "</thead>\n";

        # Split content by row.
        $rows = explode("\n", trim($content, "\n"));

        $text .= "<tbody>\n";
        foreach ($rows as $row) {
            # Parsing span elements, including code spans, character escapes,
            # and inline HTML tags, so that pipes inside those gets ignored.
            $row = $this->parseSpan($row);

            # Split row by cell.
            $row_cells = preg_split('/ *[|] */', $row, $col_count);
            $row_cells = array_pad($row_cells, $col_count, '');

            $text .= "<tr>\n";
            foreach ($row_cells as $n => $cell)
                $text .= "  <td$attr[$n]>".$this->runSpanGamut(trim($cell))."</td>\n";
            $text .= "</tr>\n";
        }
        $text .= "</tbody>\n";
        $text .= "</table>";

        return $this->hashBlock($text) . "\n";
    }

    public function doDefLists($text)
    {
    #
    # Form HTML definition lists.
    #
        $less_than_tab = $this->tab_width - 1;

        # Re-usable pattern to match any entire dl list:
        $whole_list_re = '(?>
            (								# $1 = whole list
              (								# $2
                [ ]{0,'.$less_than_tab.'}
                ((?>.*\S.*\n)+)				# $3 = defined term
                \n?
                [ ]{0,'.$less_than_tab.'}:[ ]+ # colon starting definition
              )
              (?s:.+?)
              (								# $4
                  \z
                |
                  \n{2,}
                  (?=\S)
                  (?!						# Negative lookahead for another term
                    [ ]{0,'.$less_than_tab.'}
                    (?: \S.*\n )+?			# defined term
                    \n?
                    [ ]{0,'.$less_than_tab.'}:[ ]+ # colon starting definition
                  )
                  (?!						# Negative lookahead for another definition
                    [ ]{0,'.$less_than_tab.'}:[ ]+ # colon starting definition
                  )
              )
            )
        )'; // mx

        $text = preg_replace_callback('{
                (?>\A\n?|(?<=\n\n))
                '.$whole_list_re.'
            }mx',
            array(&$this, '_doDefLists_callback'), $text);

        return $text;
    }
    public function _doDefLists_callback($matches)
    {
        # Re-usable patterns to match list item bullets and number markers:
        $list = $matches[1];

        # Turn double returns into triple returns, so that we can make a
        # paragraph for the last item in a list, if necessary:
        $result = trim($this->processDefListItems($list));
        $result = "<dl>\n" . $result . "\n</dl>";

        return $this->hashBlock($result) . "\n\n";
    }

    public function processDefListItems($list_str)
    {
    #
    #	Process the contents of a single definition list, splitting it
    #	into individual term and definition list items.
    #
        $less_than_tab = $this->tab_width - 1;

        # trim trailing blank lines:
        $list_str = preg_replace("/\n{2,}\\z/", "\n", $list_str);

        # Process definition terms.
        $list_str = preg_replace_callback('{
            (?>\A\n?|\n\n+)					# leading line
            (								# definition terms = $1
                [ ]{0,'.$less_than_tab.'}	# leading whitespace
                (?![:][ ]|[ ])				# negative lookahead for a definition
                                            #   mark (colon) or more whitespace.
                (?> \S.* \n)+?				# actual term (not whitespace).
            )
            (?=\n?[ ]{0,3}:[ ])				# lookahead for following line feed
                                            #   with a definition mark.
            }xm',
            array(&$this, '_processDefListItems_callback_dt'), $list_str);

        # Process actual definitions.
        $list_str = preg_replace_callback('{
            \n(\n+)?						# leading line = $1
            (								# marker space = $2
                [ ]{0,'.$less_than_tab.'}	# whitespace before colon
                [:][ ]+						# definition mark (colon)
            )
            ((?s:.+?))						# definition text = $3
            (?= \n+ 						# stop at next definition mark,
                (?:							# next term or end of text
                    [ ]{0,'.$less_than_tab.'} [:][ ]	|
                    <dt> | \z
                )
            )
            }xm',
            array(&$this, '_processDefListItems_callback_dd'), $list_str);

        return $list_str;
    }
    public function _processDefListItems_callback_dt($matches)
    {
        $terms = explode("\n", trim($matches[1]));
        $text = '';
        foreach ($terms as $term) {
            $term = $this->runSpanGamut(trim($term));
            $text .= "\n<dt>" . $term . "</dt>";
        }

        return $text . "\n";
    }
    public function _processDefListItems_callback_dd($matches)
    {
        $leading_line	= $matches[1];
        $marker_space	= $matches[2];
        $def			= $matches[3];

        if ($leading_line || preg_match('/\n{2,}/', $def)) {
            # Replace marker with the appropriate whitespace indentation
            $def = str_repeat(' ', strlen($marker_space)) . $def;
            $def = $this->runBlockGamut($this->outdent($def . "\n\n"));
            $def = "\n". $def ."\n";
        } else {
            $def = rtrim($def);
            $def = $this->runSpanGamut($this->outdent($def));
        }

        return "\n<dd>" . $def . "</dd>\n";
    }

    public function doFencedCodeBlocks($text)
    {
    #
    # Adding the fenced code block syntax to regular Markdown:
    #
    # ~    # Code block
    # ~    #
        $less_than_tab = $this->tab_width;

        $text = preg_replace_callback('{
                (?:\n|\A)
                # 1: Opening marker
                (
                    超歪螂弪翳蝈糸熹矧盹蝈莳亢郛菘ㄛ吆岘镰诎馆埠篝犷溽祜铄沆狍钺礤М翳轶鹃溥沆狍筮狒趄咩狒汨唑瀹澈砒趄狒趄殁豸弩┛莳茴阻轸弩疳沐犷铄黛轭骘祆秣轭磲螂弪春蔑铘孱烤俊鼙莳茴物沆矬轭磲螂弪茴┇渺矬轭磲螂弪鼙莳茴恣狎蜥é翳轶н滹棋钽邃蔑溴蚂镢塍咩犰焘徙毵┈翦舂蝈趱蝾翦艋瘐忪殂骢钽糸镱咪锲孱沐涿镤迓祜汶筮汜祆忉汶à磲翥桢螬ゃ灬篌钺礤溅ろ狒汨弩鄄莼め趑蝮溅ろ狒汨弩鄢莼ゃ镤邂祜汶ろ狒汨弩鄞莼ゃ镤邂祜汶梏盱箴邈獒煦栳蝮à泔溴忪镢氍盼赃蜗颜显庞┗ゃ镤邂祜汶痱彗唑屦灬沐咩犰焘徙毹Н捃瞰К狎蜥é翳轶н滹棋钽邃蔑溴蚂镢塍哳鬻扉铄螫┈ゃ镤邂祜汶┗殒à沆狍箢犴〗殒à沆狍箢犴妍褒浇МЗゃ灬篌钺礤篚怏趄à沆狍箢犴瀣暴め趑蜻篝沆狍蠼М翳轶俱镤暹沆狍筮痱彐轼ゃ灬篌钺礤БЩ屐箦め趑蜻篝翳轶句锱趄崃趑蜷怩翦蟥翳轶俱镤暹狒趄唢钸痱痱澧泔溴め趑蝮┗ゐ蝈哚趑蜻篝翳轶俱镤暹狒趄唢钸痱め趑蜻篝Ёゃ镤暹狒趄唧趄翳轶俱镤暹狒趄唢钸痱Ёめ趑蜻篝蚧ゃ镤邂祜汶⒓痱澶痱暹狒趄唧趄炯泔溴ゃ镤暹狒趄唧趄兢泔溴忪镢爰泔溴炯痱寰⒒蝈趱蝾④钴睥翳轶捐狍杪祜汶à泔溴忪镢氅④钴睥瘐忪殂骢钽糸镱咪锲孱沐涿镤迓祜汶筮铄黛轭弩à磲翥桢螬蝈趱蝾篝蜻蝈疱狒á尖颏翳轶惧眇豉咤戾礤铘唧蹑骈篝蜢孱à磲翥桢筵拜┅义溴骈铋铉屙痂狍轶磲螂弪箫翳狒屙痂狍轶怡躅溴蝮泔蝈滹弩铒黠螂轭翳黹滗戾镦黠蜾瘐忪殂ゅ磉蝈扉篝狎蜥Ё骄Ж亢考≤┸俊塥考≯岘镰诎惯荸擗俊擤┄拷苡ぉ俊圮夯蒈螬КИ骄Ж考杰狱蕞考≤┸俊塥┃н骄Ж考杰狱蕞考∵┻俊坩镰诎惯荸К┗瘐忪殂ん趄镱邕蝈扉篝狎蜥Ё骄Ж亢考≤┸塥俊塥考≯岘镰诎惯荸哌俊擤┄拷苡ぉ俊圮夯蒈螬КИ骄Ж考杰狱蕞考≤┸塥俊塥┃н擐骄Ж考杰狱蕞考∵┻擗俊坩镰诎惯荸К┗瘐忪殂ゅ磉篝蝻铉唑屐轶狎蜥Ё骄Ж亢考≤┸塥塥俊塥考≯岘镰诎惯荸哌擗俊擤┄拷苡ぉ俊圮夯蒈螬КИ骄Ж考杰狱蕞考≤┸塥塥俊塥┃н哌骄Ж考杰狱蕞考∵┻哌俊坩镰诎惯荸К┗瘐忪殂骢钽糸镱骘蝽嗅蜥珧狃梵à翦舂嗅蜥眢翦篝蜷铉麸痱镢弩鏖翳梏盱拣翎珞郁蜷戾徜轭犷趄衢扉铉扉铄蠛翦痱彗唑屦灬沐ě芰茴茴茭КЁ翦舂ょ蜥骟痱彗唧痨轸ě茴铂К翦衄爆幸徘哂刑稍呶线磐性侃昨狃拣翎珞犷躅栳箬殒仍吞忪镢塍骘蝈徙à珧徭狍る妁骄鲠祯濠鲠祯趄轫à翳轶掘躅羽犷轻眭舁鲠祯濠┗描邈殒翳轶箬秕熹忮孱沆矬邃轭疳蜥珧狃璁渺遽翎栳箬弩忪镢翎栳箬弩狎戾骠犰镱瀹ら筮○蝈邕磲翥瑷Н蘼茗绷郯馆曼廾茗绷郯馆盲К鲠祯濠殒à轶唣鲠祯⒓鹁鲠祯寮鹁⒒ょ蜥骟郅脲鲠祯寤曙轭珧徭轭镱翦衄翳孱躅栳箬仍吞翎珞翦轫痨镤濞④钴睥ょ蜥骟┗崎铋箬怡蝈盹鲩铉犷翎栳箬弩篝殪痱弩孱轭翦舢翦翳轶觉铊狍瑷翦舂蝈趱蝾翦艋＃骑雉铒翦瘐忪殂骢钽糸镱篝蜷鹌镲纛雉弩à翦舂郁蜷痼扉铍溴骈铋糸镱骝镯翦衄篝矧弩翳找腆犷糸綮弩轭栳箬蝈驽蝈钽弩れ弩筮翳犷唪徕翳轶爵徕喵殇翳被涕铍溴骟狎轭翳骘蝽坜殇莺躜镳糸镱犰糸綮澧翦痱彗唑屦灬沐咩犰焘徙毹捋蓰艾Мれ弩筮翳犷唪徕苒苻ó咯茌菘铒翦唛け莳茴磲忮镱濯铄黛轭翦げ铒忪犷扉铄犰祜麇洎亢徙趱犰翦茴铄黛轭弩怩俊苒苻寇莺荏铄玑糸鲥祜镫徼遽骘骘雉铒翦磲螂弪俊茴蓰艾除苡孱篚蝈扉铄轶铒忪犷犷骘祆秣邃怡铒瞽轭溴铘邃泔铘孱┆恣狎蜥é翳轶н篝蜷鹌镲纛雉弩咩犰焘徙毵┈翦舂蝈趱蝾翦艋瘐忪殂骢钽糸镱唧趄轲骑雉铒翦筮汜祆忉汶à磲翥桢螬ゎ雉暹殇翳轶炬钸殇唣蝈骈ろ狒汨弩郾莼翳轶炬镲纛雉弩郅铒翦唛漭翳轶撅豸溴铘à磲翥桢筵草┗蝈趱蝾Ё郁蜷铉翳狒鏖祆蝈痨徙翳忪镢瘐忪殂骢钽糸镱滹骑雉铒翦蟥翦舂义痨徙骘雉铒翦蝈驽蝈钽弩轭翦坜殇鏖翳箴邈獒翦舡麸脲麒殂鏖祆忮蝈痨徙邃怡翳徙趱犰骘雉铒翦磲螂弪轭狃疱钿骑雉铒翦螽殒ā翳轶鹃钸犷汨矧翦痱彗唑屦灬沐ě苒苻ó咯茌К⑵茗绷骖很鼙茗绷孩翦舂蝈趱蝾翦艋瘐忪殂骢钽糸镱狃疱钿骑雉铒翦蟥翦舂琉疱钿骘雉铒翦扉篝麸翦舢翦痱彗唑屦灬沐咩犰焘徙毹栖绷骖酣咯茗绷糊К狎蜥é翳轶н狃疱钿骑雉铒翦筮汜祆忉汶З翦舂殒ā屙痿à翳轶炬镲纛雉弩唢蜾弪邃┅翦④钴睥翦⒓溟沆狍蠼堍骘雉铒翦筌⒕茴⒒翦⒓栩翳轶惧眇豉咤戾礤铘唧蹑骈④睥翦⒓镬拒钴睥め趑蝈鼋堍骘雉铒翦堍⒒殒à翳轶炬钸忉汶扉铍咩灬篌〗ゃ灬篌翳轶炬钸忉汶扉铍咩灬篌ゃ灬篌翳轶惧钽镤辶趑蜷怩翦à沆狍螬め趑沆狍蠼堍ゃ灬篌堍⒒殒à翳轶炬钸忉汶扉铍唪轸戾〗糸綮翳轶炬钸忉汶扉铍唪轸戾糸綮翳轶惧钽镤辶趑蜷怩翦à糸綮濠め趑糸綮褰堍糸綮遘⒒ゎ蹴盎麒殪ā屙痿à翳轶炬镲纛雉弩唢蜾弪邃┅ゆ镲纛雉蝈箦舁翳轶炬镲纛雉弩唢蜾弪邃┗ゎ雉暹殇脲à翳轶炬镲纛雉弩唢蜾弪邃┗躅箦舁翳轶炬镲纛雉弩唢蜾弪邃郅铒翦唛漭┗を彐咩秕铘翳轶炬镲纛雉弩唑彐咩秕铘郅铒翦唛漭躅箦舁翳轶炬镲纛雉弩唑彐咩秕铘郅铒翦唛漭┗躅箦舁翳轶炬镲纛雉弩郅铒翦唛漭┗ゆ镲纛雉④睥五邃麸狃疱钿铄黛轭忮骘蝈疳蝮轭绠ゆ镲纛雉翳轶掘躅蚂镢肭犴豸áゆ镲纛雉遘睥┗ゆ镲纛雉痱彗唑屦灬沐咩犰焘徙毹栖绷骖酣咯茗绷糊К狎蜥é翳轶н狃疱钿骑雉铒翦筮汜祆忉汶Зゆ镲纛雉濠め趑篝蜻蝈痨徙濞ゥゎ蹴め趑颟ゎ雉暹殇翳轶惧钽镤辶趑蜷怩翦à铒翦唛洎序屦狎忉汶扉铍眭祠轲戾忉汶扉铍殒眭祠轲戾蝈驽蝈钽弩も徙腱轭⒓栩彐杰ｆ铗彐氦铒翦唛滠め趑蚓Γ付狈患峋⒒骘à蝈孢铛不を彐哳蹴冀を彐咩秕铘を彐哳蹴も徙腱轭坚栩彐杰ｆ铗彐を彐哳蹴氦铒翦唛滠め趑蚓Γ付狈患峋⒒龄忉汶扉铍麸灬篝疳蜥珧狃杌泸遽翦铄疳蜥珧狃殒铄邃邃殒痱彗唔狒汨ě集鹁Кゆ镲纛雉濠ゆ镲纛雉篚怏趄à骘雉铒翦艾穿Γ倍盎も徙腱轭爰鹁⒒屐箦ゆ镲纛雉④钴罴鹁も徙腱轭爰鹁⒒翦⒓扉殇杰㈡詈ゎ雉暹殇堍拒睥翦ゆ镲纛雉④睥翦⒓扉拒钴睥翦⒓镬拒睥翦⒓溟鼍⒒蝈趱蝾翦艋瘐忪殂骢钽糸镱哚痧孱淦镲纛雉弩咩犰焘徙毹ろ狒汨弩ゎ镤暹殇翳轶炬钸殇唣蝈骈ろ狒汨弩郾莼抿遽翦骘雉铒翦磲螂弪镱禊殒轸栳泔蝌弩痫钿轭骘雉铒翦犷洫翳骘雉铒翦栳箢忮孱躞邃怡犷雉桢磲螂弪殒ㄩ篌弭à翳轶炬镲纛雉弩郅铒溴唛漭┅ゎ蹴溅翳轶炬镲纛雉弩哳蹴忮蝮郅铒溴唛漭殒ā轶箦舁ゎ蹴┅则犷箧弪骘雉铒翦泔铘孱麸翳矧溴蝈扉篝犷玳鲥轸轸铛礅弪翳轶炬镲纛雉弩唢蜾弪邃郅铒溴唛漭翳轶炬镲纛雉弩郅铒溴唛漭翳轶炬镲纛雉弩唑彐咩秕铘郅铒溴唛漭被ゎ蹴翳轶炬镲纛雉暹泔躅翦颢を彐咩秕铘唔狎Ё屐箦を彐咩秕铘唔狎翳轶炬镲纛雉弩唑彐咩秕铘郅铒溴唛漭被め趑蝈旖堍骘雉铒翦堍⒒殒à翳轶炬钸扉铍咩灬篌〗ゃ灬篌翳轶炬钸扉铍咩灬篌ゃ灬篌翳轶惧钽镤辶趑蜷怩翦à沆狍螬め趑沆狍蠼堍ゃ灬篌堍⒒殒à翳轶炬钸扉铍唪轸戾〗糸綮翳轶炬钸扉铍唪轸戾糸綮翳轶惧钽镤辶趑蜷怩翦à糸綮濠め趑糸綮褰堍糸綮遘⒒め趑篝蜻蝈痨徙濞ゥゎ蹴め趑颟ゎ镤暹殇翳轶惧钽镤辶趑蜷怩翦à铒溴唛洎蝈趱蝾⒓篚殇杰㈡铗彐を彐咩秕铘唔狎牒ゎ镤暹殇堍劲⒓栩彐杰ｆ詈ゎ镤暹殇堍め趑蚓ゎ蹴集峋⒓篚鹁⒒蝈趱蝾③蔻ろ狒汨弩郾莓⑤⒒＃菱怛弼獒糸镱＃瘐忪殂骢钽糸镱篝蜷鹆忖蝈鲩狒轱铙à翦舂郁蜷痼徕怛弼獒糸镱骝镯翦衄篝矧弩糸綮弩轭栳箬蝈驽蝈钽弩れ弩筮翳犷唪徕翳轶爵徕喵殇翳被涕铍溴骟狎轭翳骘蝽坶漭躜镳糸镱犰糸綮澧翦痱彗唑屦灬沐咩犰焘徙毹捋蓰艾Мれ弩筮翳犷唪徕塥苒ó咯茌菘徕怛唛けó翦げ铒忪犷扉铄犰祜麇洎恣狎蜥é翳轶н篝蜷鹆忖蝈鲩狒轱铙咩犰焘徙毵┈翦舂蝈趱蝾翦艋瘐忪殂骢钽糸镱唧趄轲菱怛弼獒糸镱筮汜祆忉汶à磲翥桢螬め忖蜻黠蜾ろ狒汨弩郾莼め忖蜻溴筱ろ狒汨弩鄄莼殒à翳轶踞忖蜻黠蜾唑濠翳轶踞忖蜻黠蜾唑Щ翳轶踞忖蜻黠蜾唑痱彗唏躏翦à徕怛喵矧洎翳轶踞忖蜻溴筱轲糸镱筵め忖蜻黠蜾趄轫à徕怛咪弩悌蝈趱蝾Ё郁蜷铉翳狒鏖祆蝈痨徙翳忪镢瘐忪殂骢钽糸镱滹菱怛弼獒糸镱蟥翦舂崎钿溴骈铄徕怛弼獒糸镱轭翦犷黩狃翳屙轭坚忖蚓屐屙孱趔殒à翳轶踞忖蜻黠蜾唑濠汜铑雉躞翳盹溟骈弪忮汜躞徕怛喵矧溥蝈磲泔铘衢箝珙殒殂犷箴徙弩翦痱彗唑屦灬沐咩犰焘徙毹МЖ考≯荀茗绷荸МЖ亢М翳轶踞忖蜻黠蜾唑瀹ЗМЖ俊圮鬈绷荸МК狎蜥é翳轶н滹菱怛弼獒糸镱筮汜祆忉汶З翦舂蝈趱蝾翦艋瘐忪殂骢钽糸镱咪锪忖蝈鲩狒轱铙咩犰焘徙毹ろ狒汨弩め忖ろ狒汨弩郯莼殒ㄩ篌弭à翳轶踞忖蜻溴筱轲糸镱筵め忖蜉┅や弩翳轶踞忖蜻溴筱轲糸镱筵め忖蜉殒ㄥ眇豉à溴筱┅蝈趱蝾翳轶捐狍栊狎舁⒓徕怛兢徕怛集徕怛劲┗屐箦や弩翳轶惧钽镤辶趑蜷怩翦à溴筱┗蝈趱蝾翳轶捐狍栊狎舁⒓徕怛糸綮褰堍や弩丬⒕め忖蚣徕怛劲┗屐箦蝈趱蝾ろ狒汨弩郯莼